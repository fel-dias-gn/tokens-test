'use strict';

const _ = require('lodash');
const fs = require('fs');
const path = require('path');
const chokidar = require('chokidar');
const EventEmitter = require('events');
const util = require('./util');

const loader = require('./loader');

const TYPES = loader.TYPES,
  CORT_SCHEMA = loadCortSchema(),
  BANK = require('./bank');

module.exports = {
  load,
  loadFile,
  file: loadFile,
  loadFlash,
  flash: loadFlash,
  bank: BANK,
  createDynamicData,
};

function loadCortSchema() {
  var defaultTypes = _.clone(TYPES),
    cortTypes = loadCortTypes(),
    types = defaultTypes.concat(cortTypes),
    schema = loader.Schema.create(
      defaultTypes.concat(cortTypes)
    );
  return schema;
}

function loadCortTypes() {
  var types = [];
  _.each(require('./types'), Pattern => {
    var item = new Pattern(),
      item = Object.assign(item, {
        load: (source, options) => load(source, options),
        loadFile: (filename, options) => loadFile(filename, options),
      }),
      set1 = item.options || {},
      set2 = item.getOptions ? item.getOptions() : {},
      tag = set1.tag || set2.tag || item.tag,

      resolve = set1.resolve || set2.resolve || item.resolve,
      construct = set1.construct || set2.construct || item.construct,
      represent = set1.represent || set2.represent || item.represent,

      options = {
        kind: set1.kind || set2.kind || item.kind,
        instanceOf: set1.instanceOf || set2.instanceOf || item.instanceOf,

        resolve: resolve ? resolve.bind(item) : null,
        construct: construct ? construct.bind(item) : null,
        represent: represent ? represent.bind(item) : null,
      };

    types.push(new loader.Type(tag, options));
  });

  return types;
}

function load(source, options = {}, name) {
  options.schema = options.schema || CORT_SCHEMA;
  var raw = loader.load(source, options),
    data = name ? _.get(raw, name) : raw;
  return data;
}

function loadFile(file, name) {
  var filename = util.pickExt(file),
    source = fs.readFileSync(filename, 'utf-8'),
    data = createDynamicData(
      load(source, { filename }, name),
      filename
    );
  data.__filename = data.__filename || filename;
  return data;
}

function createDynamicData(data = {}, filename) {

  var handlers = {},
    options = {
      debugMode: false,
      jsonOnUpdate: false,
      jsonFilename: null,
      dumpOnUpdate: false,
      dumpFilename: null,
      filename: filename
    };

  class FlashData {

    constructor (data) {
      var self = this;
      _.extend(self, data);
    }

    save () {
      var self = this,
        filename = options.filename;
      if (!filename) { return self; }
      self.dumpToFile(filename);
    }

    debug (val) {
      var self = this;
      options.debugMode = !!val;
    }

    on (name, handler) {
      var self = this;
      handlers[name] = handlers[name] || [];
      handlers[name].push(handler);
    }

    emit (name, ...args) {
      var self = this;
      if (options.debugMode) {
        console.log( 'EMIT>>> ', name, ...args);
      }
      _.each(handlers[name], handler => {
        handler(...args);
      });
    }

    getContext (name) {
      var self = this,
        context = self;
      name.split('.').slice(0, -1).forEach(chain => {
        if (util.notObject(context[chain])) {
          return;
        }
        context = context[chain];
      });
      return context;
    }

    flatten () {
      var self = this;
      return util.flatten(self);
    }

    set (name, val) {
      var self = this;
      return _.set(self, name, val);
    }

    get (name) {
      var self = this;
      return self.verifyValue(_.get(self, name));
    }

    has (name) {
      var self = this,
        context = self.getContext(name),
        last = name.split('.').pop();
      return _.keys(context).includes(last);
    }

    filename (name) {
      var self = this,
        filename = null,
        p = name;
      while (!filename && p) {
        if (self.has(p) && self.get(p).__filename) {
          return self.get(p).__filename;
        }
        p = p.split('.').slice(0, -1).join('.');
      }
      return filename;
    }

    delete (name) {
      var self = this,
        context = self.getContext(name),
        last = name.split('.').pop(),
        value = _.get(self, name);
      delete context[last];
      self.emit('deleted', name, value);
    }

    change (name, val) {
      var self = this,
        oldValue = _.get(self, name);
      if (oldValue === val) { return; }
      _.set(self, name, val);
      self.emit('changed', name, val, oldValue);
    }

    keys () {
      var self = this;
      return _.keys(self.flatten());
    }

    eachPrimitive (handler) {
      var self = this;
      _.each(self.flatten(), (val, name) => {
        handler(val, name);
      });
    }

    each (handler) {
      var self = this;
      return _.each(self, (val, name) => {
        if (name.startsWith('__')) {
          return;
        }
        handler(val, name);
      });
    }

    eachObject (handler, o, parent) {
      var self = this,
        obj = o || self;
      _.keys(obj).forEach(key => {
        var val = obj[key],
          name = parent ? `${parent}.${key}` : key;
        if (util.notObject(val)) {
          return;
        }
        handler(val, name);
        self.eachObject(handler, val, name);
      });
    }

    clone () {
      var self = this;
      return _.cloneDeep(self);
    }

    compare (other) {
      var self = this,
        f1 = util.flatten(self),
        f2 = util.flatten(other),
        deleted = _.difference(_.keys(f1), _.keys(f2)),
        added = _.difference(_.keys(f2), _.keys(f1)),
        changed = _.keys(f2).filter(key => f1[key] !== f2[key]);

      return {
        deleted, added, changed,
        equal: _.difference(
          _.keys(f1),
          deleted
            .concat(added)
            .concat(changed)
        )
      };
    }

    toArray (path, name = 'name') {
      var self = this,
        val = path ? self.get(path) : self;
      if (typeof val !== 'object') {
        return null;
      }
      return util.objectsToArray(val);
    }

    update (other) {
      var self = this,
        status = self.compare(other);
      _.each(status.deleted, key => {
        self.delete(key);
      });
      _.each(status.added, key => {
        var val = _.get(other, key);
        self.set(key, val);
        self.emit('added', key, val);
      });
      _.each(status.changed, key => {
        self.change(key, _.get(other, key));
      });
      if (options.jsonOnUpdate) {
        self.jsonToFile(options.jsonFilename);
      }
      if (options.dumpOnUpdate) {
        self.dumpToFile(options.dumpFilename);
      }
      self.clearMeta();
      return self;
    }

    findKeys (f) {
      var self = this,
        find = f.toLowerCase();
      return self
        .keys()
        .map(key => key.toLowerCase())
        .filter(key => key.indexOf(find) > -1);
    }

    verifyValue (val) {
      var self = this;
      if (!val) { return val; };
      if (util.isObject(val)) {
        return val;
      }
      if (Array.isArray(val)) {
        return _.filter(val);
      }
      return val;
    }

    getParent (key) {
      var self = this,
        parts = key.split('.'),
        jk = parts.pop(),
        p;
      while (parts.length) {
        p = parts.join('.');
        if (self.has(p)) {
          return self.get(p);
        }
        parts.pop();
      }
      return self;
    }

    compileData (keys) {
      var self = this,
        data = {};
      _.each(keys, key => {
        return _.set(data, key, self.get(key));
      });
      return data;
    }

    clearMeta () {
      var self = this,
        metaKeys = self
          .keys()
          .filter(file => {
            return file.includes('__filename')
              || file.includes('__parentFilename');
          });
      metaKeys.forEach(key => {
        var wrapper = self.get(key.split('.').slice(0, -1).join('.'));
        if (!wrapper) {
          return;
        }
        delete wrapper.__filename;
        delete wrapper.__parentFilename;
      });
      delete self.__filename;
      return self;
    }

    jsonOnUpdate (filename, force) {
      var self = this;
      options.jsonFilename = filename;
      options.jsonOnUpdate = true;
      force ? self.jsonToFile(filename) : '';
    }

    json () {
      var self = this;
      return JSON.stringify(self, null, 2);
    }

    jsonConsole () {
      var self = this;
      console.log(self.json());
    }

    jsonToFile (filename) {
      var self = this;
      fs.writeFileSync(filename, self.json());
    }

    dumpOnUpdate (filename) {
      var self = this;
      options.dumpFilename = filename;
      options.dumpOnUpdate = true;
    }

    dump () {
      var self = this;
      return loader.dump(self);
    }

    dumpConsole () {
      var self = this;
      console.log(self.dump());
    }

    dumpToFile (filename) {
      var self = this;
      fs.writeFileSync(filename, self.dump());
    }

  }

  var item = new FlashData(data);

  return item;
}

function loadFlash(file, name) {
  var filename = util.pickExt(file),
    data = createDynamicData(),
    files = update().concat([filename]),
    watcher = chokidar.watch(files, {
      persistent: true
    });

  watcher.on('change', () => {
    var newFiles = update();
    watcher
      .unwatch(files)
      .add(newFiles);
  });

  return data;

  function update() {
    BANK.resetRequires();
    data.update(
      loadFile(filename, name)
    );
    return BANK.getRequires();
  }
}
