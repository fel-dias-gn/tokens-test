'use strict';

const path = require('path');
const fs = require('fs-extra');
const cml = require('cortml');

const DEFAULT_OPTIONS = {
  name: '',
  desc: '',
  authorName: '',
  authorEmail: '',
  authorGithub: '',
  year: (new Date()).getYear(),
  cp: null,
};

class Package {

  constructor (options) {
    var self = this;
    self.options = options;
    self.data = {
      license: fs.readFileSync(
        path.resolve(__dirname, '../template/LICENSE'),
        'utf-8'
      ),
      package: fs.readFileSync(
        path.resolve(__dirname, '../template/package.json'),
        'utf-8'
      ),
      readme: fs.readFileSync(
        path.resolve(__dirname, '../template/README.md'),
        'utf-8'
      ),
    };
  }

  getOptions () {
    var self = this,
      data = self.options;
    data.year = data.year || `${(new Date()).getFullYear()}`;
    data.cp = data.cp || data.authorName;
    return data;
  }

  insertVals (dir) {
    var self = this,
      packageFilename = path.resolve(dir, 'package.json');
    fs.writeFileSync(
      packageFilename,
      self.replaceOptions(fs.readFileSync(packageFilename))
    );
  }

  create (dir) {
    var self = this,
      opts = self.getOptions();
    if (fs.existsSync(dir)) {
      throw new Error(`Directory «${dir}» already exists!`);
    }
    fs.copySync(path.resolve(__dirname, '../template'), dir);
    fs.writeFileSync(
      path.resolve(dir, 'LICENSE'),
      self.replaceOptions(self.data.license)
    );
    fs.writeFileSync(
      path.resolve(dir, 'package.json'),
      self.replaceOptions(self.data.package)
    );
    fs.writeFileSync(
      path.resolve(dir, 'README.md'),
      self.replaceOptions(self.data.readme)
    );
  }

  readFiles () {
    var self = this,
      dir = path.join(__dirname, '../template'),
      filenames = cml.readdirRecursive(dir),
      data = {};
    return filenames
      .map(file => path.join(dir, file))
      .filter(filename => fs.statSync(filename).isFile())
      .map(filename => {
        var source = fs.readFileSync(filename, 'utf-8'),
          name = path.relative(dir, filename);
        return {
          name: name,
          dir: path.dirname(name),
          filename: filename,
          source: source,
          code: self.replaceOptions(source)
        };
      });
  }

  replaceOptions (source) {
    var self = this,
      options = self.getOptions();
    return source.replace(
      /\{\{([^\}]+)\}\}/mgi,
      (txt, name) => {
        return options[name] || '';
      }
    );
  }

}

module.exports = {
  Package: Package
};
